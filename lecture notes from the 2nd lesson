# """
# Разбор ДЗ от первого урока
# """
# name = input("Введите свое имя")
# print("Приает, %s!" % name)
#
# age = int(input("Введите свой возраст"))
# print("Понял, тебе %d лет" % age)
#
# """
# Пользователь вводит время в секундах.
# Переводим в часы, минуты и секунды и вывести в формате чч:мм:сс.
# Используйте форматирование сторок.
# """
#
# seconds_input = int(input("Для колличества секунд: "))
# hours = seconds_input // 3600 # Целое значение от деления на кол-во сек в часе
# minutes = seconds_input % 3600 // 60 # Остаток от деления на 3600
# seconds = seconds_input % 3600 % 60 # Остаток от деления на 3600 + Остаток от деления на 60
# print(f'{hours:02d}:{minutes:02d}:{seconds:02d}')

# """
# Узнайте у пользователя число n.
# Найти сумму число n + nn + nnn.
# """
# # Это будет формат строки
# n = input("Для числп n: ")
# # Получение суммы через конкатенации строк
# nn = n + n # n * 2
# nnn = n + n + n # n * 3
# # переводим сторки к числу
# result = int(n) + int(nn) + int(nnn)
# print(result)

# """
# Пользователь вводит цел. полож. число,
# Найти самую большую цифру в числе.
# Использовать while и арифм. операции
# """
# input_number = input("Целое, положительное число: ")# Оставляем строчный тип, для перебора индекса

# # Здесь длинна введенного числа
# number_length = len(input_number)
# max_element = 0
# i = 0 # Это индекс эллемента (номирация от 0 )
# while i < number_length:
#     current_element = int(input_number[i])
#     if current_element > max_element:
#         max_element = current_element
#     i += 1
# print(max_element)
#
# input_number = list(input_number)
# #print(max(input_number))

# max_element = 0
# for element in input_number:
#     if int(element) > max_element:
#         max_element = int(element)
#
# print(max_element)

# """
#  Если фирма отработала с прибылью, вычислите рентабильность выручки
#  Т.е. отношение прибыли в выручке.
#  Далее запросите численность сотрудников фмрмы и определите фирмы и определите прибыль
#  в расчете на сотрудника
# """
# revenue = float(input("Выручка фирмы: "))
# costs = float(input("Издержки: "))
#
# profit = revenue - costs
#
# if profit > 0:
#     print(f'Рентабильность капитала равна {profit/revenue * 100:.2f}%')
#     workers_count = int(input('Введите колличество сотрудников: '))
#     print(f'Прибыль на одного сотрудника: {profit/workers_count}')
# elif profit < 0:
#     print("Фирма работает в убыток")
# else:
#     print("У фирмы нулевая прибыль")

# """
# В первый день результат спортсмено составил a километроа
# Каждый день + 10% к результату, относмтельно предыдущего
# Нпйти номер дня, в который будет b результвт.
# Принимает парам. a и b и выводит натуральное число = номер дня.
# """
#
# a = int(input("Результат в первый день: "))
# b = int(input("Желаемая дистанция: "))
# days = 1
# while a < b:
#     a *= 1.1
#     days += 1
# print(f'Спортсмен достигнет дистанции в {b} км зв {days} дней')
# # """Конспек по занятию"""
# # # Числовой тип данный = для хранения числовых значениц
# Это не изменяемый тип, все проводимые опреации с объектом
# не  меняют текущий объект. Что бы сохранить результат вычисления - нужно создать
# новую переменную и сохранить в нее.
# # """Побитовые вычисления ?"""
# a = -43.03 # float
# a = int(a) # int
# a = abs(a) # a = 43 - Исполнение по модулю
#
# print(bin(a)) # представления в двоичной системе исчесления
# print(oct(a)) # представления в восьмериченой системе исчесления
# print(bin(a)) # представления в 16тиричной системе исчесления
#
# my_int = 43 | 7 # побитовое ИЛИ
# print(my_int)
# my_int = 43 & 7 # побитовое И
# print(my_int)
# my_int = 43 << 7 # побитовый сдвиг влево ( на 2 позиции)
# print(my_int)
# my_int = 43 >> 7 # побитовый сдвиг вправо ( на 2 позиции)
# print(my_int)
#
# # Комплексные значения + можем применять арифметические опервции
# a = complex(2, 4)
# print(a)
#
# """
# Тип данных строка - так же как и цисло - не изменяемый тип данных
# - конкатенация ( + ; f' ; format ; %)  со строками
# - взятие эллемента по индексу
# - вычисление длинны строки
# - извлечение среза
# - обратная итерация
# - реверс на месте
# """
#
# # Ведет себя как коллекция ланных, тк. состря из строковых литералов
# my_string = "Ехал Грека через реку, а там рак"
#
# # print(len(my_string)) # Длина
# # print(my_string[5])# Возвращение эллем. на 5ом индкексе
# # print(my_string.index(' ')) # возвращает индекс эллем > [5]. Чувствителен к регистру
# # Возвращает только первое вхождение эллем. в строку. Пробел первый раз вошел под 4ым индексом
# # Не вернет список индексов - всех  одинаковых эллементов из строки
# """Что бы выделить (слово) целиком - задаем диапазон"""
# # print(my_string[4:10]) # Это полуинтервыл, срез от 4го индекса по 9вый
# # Делаем срезы - выдергиваем подстроки
# print(my_string[4::])  # С индекса и до конца строки
# print(my_string[4::2])  # взяьте каждого второго эллем до конца строкм.
# print(my_string[4:16:2])  # С 4го по 16 эллем. через букву - шаг 2
# print(my_string[-1])  # Взятие последнего индекса в строке, индексация с 1
# print(my_string[::-1])  # реверс строки = задам на перед
# print(reversed(my_string))
# # чтобы его напечатать, приводим список к листу (list)
# print(list(reversed(my_string)))  # каждая буква стала эллем. списка
# # что бы разделить строку на слова (split)
# print(my_string.split())  # в скобках указываем разделитель - указан пробел(стоит по умолчанию)
# # получили список из слов строки
# print("$|%".join(['Шла', 'Саша', 'по', 'шоссе']))  # Соединение слов "$|% - соединителем
# print(my_string.replace('Грека', 'Дима'))  # Замена подстроки на другую
#
# """Следующий блок, это работа с регистром"""
# print(my_string.title()) # Возвращает строку где (Все Слова С Заглавгой Буквы)
# print(my_string.capitalize()) # Возвращает строку где (Только первре лово с заглавной буквы)
# print(my_string.upper()) # Все буквы - эллем.  с заглавной буквы. Те. в верхнем регистре
# print(my_string.lower()) # Все буквы - эллем. в нижнем регистре
# print(my_string.istitle()) # проверка title() - иначе False
# print(my_string.isupper()) # проверка upper() - иначе False
# print(my_string.islower()) # проверка lower() - иначе False
#
# """ Блок методов проверяющих вхождение эллем. """
# print(my_string.count('р')) # Считает кол-во указанного эллем. в строке
# print(my_string.startswith('Ехал')) # Начинается ли моя строка, подстрока с указанного слова (аргумент)
# # Выводит True
# print(my_string.endswith('рак')) # Проверяет конец строки. Чувствителен к регистру
# print(my_string.find('через')) # Есть подстрока в строке. Возвращает индекс начала подстроки в строке
# """Методы проверок для строк"""
# print('100500fsf'.isdigit()) # Проверяет, что строка состоит из чмсел - возвращает True
# print('100500fsf  :'.isalnum()) # Проверяет строку на буквы и числа. Не примет символы - False
# print('foo'.isalpha()) # Проверяет строку на алфавитных символов
# print("\n\t ".isspace()) # Проверяет строку на пробельные символы (указаны все пробельные)
# """
# ТИП данных СПИСОК
#     -может содержать в себе все вышеперечмсленные данные
#     -есть 'массив' + библиотека "нанпай" - содержит структуру дан. отдного типа
#     списки - структуру разных типов.
#     - тип изменяемый, операции к нему применяемые - тут же меняют его.
# """
# my_list = ['a', 'b', 'c', 'd', 'e', 'f'] # список состоит из строковых значений
# my_list.append('j') # Добавление эллеменьа в конец списка
# print(my_list)
# # добавление к сипску новый или казанный список (my_list_2 = [1, 2, 3]) - my_list.extend([my_list-2])
# my_list.extend(['h', 'i', 'g'])
# print(my_list)
# # Вставляет эллемент на указанное место в списке
# my_list.insert(2, 'w')
# print(my_list)
# # можно делать конкотинацию со списком
# my_list_number = [1, 2, 3, 4, 'r', 'r', ' ']
# my_list_number_1 = [5, 6, 7, ' ', 'f']
# result = my_list_number + my_list_number_1
# print(result)
#
# # удление указанного эллем. из списка, ошиька - если эллем там нет
# result.remove(' ')
# print(result)# если эллем. повторяется - удалится первый
#
# #print(result.pop(10)) # Удаление эллем. по идексу + вернет значение удаленного
# result.pop(9)
# print(result)
#
# # вхожденик эллем. по индексу
# print(result.index('r'))
# # возвращение эллем с 3им индексом. Как и в строках
# print(result[3])
#
# # добавляем эллем. в список и медодом count подсчитываем поаторяюшиеся
# my_list.extend(['a', 'a', 'b', 'c', 'a'])
# print(my_list.count('a'))
#
# # Делаем срезв
# print(my_list[3:9:1]) # По умолчанию стоит [3:7:1 - шаг]
# print((my_list[2::3]))

# Сортировка списка в порядке возрастания - если числа
# my_list.sort(reverse=False)# True - развернет список. False=без указ. аргумен.
# print(my_list) # В алфавитном порядке т.к. строковые данные в списке
#
# my_list.reverse()
# print(my_list)

# после сортировки можно  сделать реверс - развернуть список с зади на перед
# print(my_list[::-1]) # из-за отрицательной индексации
# print(list(reversed(my_list))) # или метода reversed

# Создание копии списка
# my_list_copy = my_list.copy()
# # print(my_list_copy)
# #
# # # Удаляет все эллементы из списка
# # my_list_copy.clear()
# # print(my_list_copy)
#
# # нумерация каждого эллемента в списке
# print(list(enumerate(my_list_copy, 1))) # возвращает картеж
# # вторым аргументом указывается индекс старта

# """
# Тип данных картеж - в () скобках
#     -как список, но не изменяемый
#     -это для безопасности от неверных воздействвий пользователя
#     -поддержка тех же операций что и список
#     -создаем новые переменные для изменений
#     (методы append, remove, insert не  поддерживаются.
# """
# a = 1
# b = 2
# print(a, b)
# a, b = b, a # присваивание через картеж
# print(a, b)
# a = b = c = d = 44 # множественное присваивание
# print(a, b, c, d)
#
# my_tuple = (2, 4, 6, 8, 10)
# print(my_tuple.index(8))
# print (my_tuple[3])
# # Создаем новый объект
# new_tuple = my_tuple + (12, 14, 16, 18) # Исхожный картеж при этом не изменится
# print(my_tuple)
# print(new_tuple)
#
# print(new_tuple[2:4])
# print(new_tuple.count(12))

# a =([1, 2, 3])
# print(type(a)) # class 'list'
# a = ('s')
# print(type(a)) # class 'str'
# a = ([1, 2, 3,],)
# print(type(a)) # class 'tuple'
# a = 1, 2, 3, 4, 5, # class 'tuple' - картеж можно задать без скобок
# print(type(a))


# """
# Тип данных множество - set
#     - изменяемый тип, изменения будут отражены в объекте
#     -содержит уникальные зллем.
#     add(зллем.)
#     remove(зллем.)
#     discard(зллем.)
#     pop()
#     copy()
#     clear()
#
#     union(множество) ИЛИ |
#     intersection(множество) ИЛИ &
#     difference(множество) ИЛИ -
# """
# my_set = set([1, 2, 3, 4, 5, 6, 7])
# my_frozenset = frozenset([9, 8, 7, 6, 5]) # по аналогии со списком и картежем
# # Добовление 1 эллем. последним в сет
# my_set.add(8)
# print(my_set)
# # удаление 1 указанный эллем. из множества
# my_set.remove(2) # если эллем. нет - ошибка
# print(my_set)
# # так же удаляет, но ошибку не выдаст при отсутствии эллем.
# my_set.discard(7)
# print(my_set)
# # удаление первого эллем. и возвращение его значения
# print(my_set.pop())
# # копирование мнржества
# my_set_copy = my_set.copy()
# # удаление всех эллем. в коллекции
# my_set.clear()
#
# print(my_set_copy.union(my_frozenset)) # объединение множеств
# print(my_set_copy.intersection(my_frozenset)) # пересечение множеств - повторяюшиеся эллем.
# print(my_set_copy.difference(my_frozenset)) # разница множеств
#
# """
# Тип словарь
#     -дает значение только по ключу
#     -изменяемый тип
#     -ключи это не изменяемый тип, используем число и строки
# """
# my_dict = {'jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4}
# print(my_dict.keys()) # значение всех ключей
# print(my_dict.values()) # список всех значений словаря
# print(my_dict.items()) # пары  ключей + значения
#
# print(my_dict['Feb']) # значение под ключом. Если такого нет - ошибка
# print(my_dict.get('jul', 6)) # значение под ключом. Если такого нет - ошибки не будет
#
# # даление указанного ключа + возврат его значения
# print(my_dict.pop('Mar'))
# print(my_dict.popitem()) # удаление последней пары, картеж (ключ-значение)
# # добавляет ключ, не указавая 2ым арг. значение - поставит None
# print(my_dict.setdefault('Jul')) # так выведет значение  добавленного ключа - None
# print(my_dict)
# # добавляет новый ключ с указанным значением
# my_dict.setdefault('Sep', 9)
# print(my_dict)
# # обновление словаря. Если ключи были - обновляет. Если небыло - добавит
# my_dict.update({'Oct': 10, 'Jul': 7})
# print(my_dict)
# my_dict_copy = my_dict.copy() # копирование
# my_dict_copy.clear() # удаление данных
# print(my_dict_copy) # пустая структура

# """
# Тип данных boll
#     - применяется в витвлениях
#     - произошли от целочисленного типа данных
#     True = 1, False = 0
# """
# print(True) # все тру, приводится к этому типу
# print(bool(20))
# print(bool('text'))
# print(20 > 1)
#
# print(False) # все ложь, приводится к этому типу
# print(bool(0))
# print(bool(''))
# print(bool())
#
# """
# Байты
#     - bytes это не изменяемый тип
#     - byterray изменяемый
# """
# print(b'text')
# print(bytes('text', encoding='utf-8'))
#
# my_string = "Python is interesting."
# arr = bytearray(my_string, 'utf-8')
# print(arr)
# print(arr[7]) # по обращению к эллем.массива - вернется значение байта

# """
# Тип None
#     - это ничего, пустота
# """
#my_dict = {'name': 'Ivan', 'surname': 'Ivanov', 'age': '48', 'position': None}
# #
# """
# Исключения
#     - обработка ошибок
# """
# # работает на подобие логических веток
# try: # попробуй исполнить такой кусок кода
#     print(500/0) # На 0 не делят - ошибка
# except ZeroDivisionError: # вoзможная ошибка
#     print("деление на ноль") # сообщение о ошибке
#     # если не получится, тогда сделай это

# my_dict = {'name': 'Ivan', 'surname': 'Ivanov', 'age': '48', 'position': None}
# try:
#     print(my_dict['3'])
# except Exception: # родительский класс, от него произошли все ошибки (если не знаем что указввать)
#     print('нет такого ключа') # или так ( as e:), в принте ( узнаем тип ошибки),
#     # вторым аргументом указать type(e)-  KeyError - поставить в исключение
# finally: # + дополнительная ветка
    #print('конец')
# else: # выполнится когда в блоке try не будет ошибки
# здесь можно прописывать основной блок кода
#
# """
# Тернальный оператор
    # - когда логические операции можно сплющить в одну строчку кода
    # - работает с легкими структурами - двумя логическими ветками
# """
# if 5 > 4:
#     print(True)
# else:
#     print(False)

# result = print(True if 5 > 4 else False)
# print(True) if 5 > 4 else print(False)

# condition = False
# personaliti = ('не проверенно', 'проверенно')[condition] # объявлен картеж, по нему изымаем значение 0 или 1
#                                                          # False = 0. в картеже важно расставить значения по индексу
#                                                          # здесь возвращается значение от 0го аргумента
# print(personaliti)
#
# """
# Операторы is и in
#     is - сравнение по ссылке(на идентичность обьектов)
#     in - проверка на вхождение эллемента в контейнео данных
# """

